git config --global user.name 用户名 ||设置用户名
git config --global user.emil 邮箱   ||设置用户签名
git init |初始化本地库
git status |查看本地库状态
git add | 文件名 添加缓存区
git commit -m “日志信息” 文件名 | 提交到本地库
git reflog | 查看历史记录
git reset --hard |版本号 


/*注释*/

$ git commit -m "git的第一次提交日志"
[master (root-commit) 901538f] git的第一次提交日志
 1 file changed, 8 insertions(+)
 create mode 100644 "\350\256\260\344\272\213\346\234\254.md"

901538f 就是版本号

切换版本号*/


git reflog 查看版本信息查看heade指向哪个版本 最前面有版本号
git reset --head 901538f 切换到这个版本号
git status 查看当前状态
cat 记事本.md 查看文件状态

第四章 分支操作 */

操作 /*制造冲突*/

git branch 分支名 | 创建分支
git branch -v |查看分支
git checkout 分支名 |切换分支
git merge 分支名 | 把指定的分支合并到当前分支上

--测试test1分支变化
git add 记事本.md git commit -m "test1分支修改内容" 记事本.md

/*test1分支制造冲突*/


在手动修改代码地区的时候
会有箭头和等于，head部分告诉你哪里冲突

合并后不要加上文件名提交
如
git commit -m "解决了冲突"


/*代理*/

可以src下使用setupProxy.j来配置代理
和package.json中配置代理 
package.json 中直接加上
"proxy" : "http://localhost:5000"

请求部分要向本地发送代理会转向五千发送
站在3000给3000发，3000有代理转发给五千


 axios.get(`http://localhost:3000/search/users?q=${value}`).then((response) => {
                console.log(response.data)
         }, 
         error => { console.log(error); })



晚上使用了git clone url 来下载克隆下项目 只需要在项目环境中 npm install 安装依赖即可
提交的时候如果没有.gitignore 则自己加一个里面填写依赖的路径比如当前路径下的react_staging/node_modules



/*github案例搜索信息*/

应该展示的是没检索出的默认信息
检索中的loading，检索失败的error

做了请求检索前的用三元表达式处理，list组件是展示列表区域
可以用三元表达式在app定义的状态first第一次展示欢迎页内容为真展示字符所以app初始状态first为true在检索
过后为false但loading为true，
loading展示loading状态，在请求完成稿的response中更改该状态loading为false和渲染数据
失败的话就error回调中更新状态，并把err:error.message给传递给app更新状态

axios.get('url')是promise对象请求，需要用.then来执行回调.then(res=>{},error=>{})成功的回调函数和失败的回调函数
回调函数就是函数自己执行的函数


/*消息订阅和发布*/
兄弟组件之间的通信
pubsub-js 消息订阅和发布的库
05-github搜索案例 npm install pubsub-js

//订阅消息可以在任何组件中进行
componentDidMount(){
       this.token = PubSub.subscribe('atguigu',(_,stateobj)=>{
              this.setstate({stateobj}) //订阅atguigu消息，获取两个参数一个名字message和data，基本在渲染完成后的钩子调用
       })
}
//发布消息直接调用该函数即可调用
PubSub.publish('atguigu',{isLoading:false,users:response.data.item})

componentWillUnmount(){
       PubSub.unsubscribe(this.token) 取消订阅
}


/*fetch发送请求*/

注重关注分离就不是一下子把数据给你而是先告诉你联系成功没有

在search那边请求先折叠

首先联系服务器成功或者失败，关注分离思想
服务器响应了成功或者失败都是联系服务器成功，之后在看返回第一次没有数据
请求后的两个回调一responese.json()中获取数据
return responese.json()
promise.then的返回是非promsie值的时候返回的状态就是成功的值是undefined
如何联系服务器都失败了就没必要往下走就可以返回一个中断的promise 在error的回调中
return new  Promise(()=>{});

promise.then.then的时候可以统一处理错误不用一个一个的error用cath( (error)=>{consolog.(error)} )

fetch(`api/v1/search/users2q=${value}`).then(
       response => return response.json(),
       err => return err
).then(

       )


await 只能等到成功的结果 要在最近的函数上使用async关键字箭头函数就括号左边
因为await只能等到成功的结果所有用try( //可能出错的代码块
       请求代码块
)catch(error){
       consolog.('error')请求出错的结果，能带来错误信息
}

 //发送网络请求---使用fetch发送（未优化）
        /* fetch(`/api1/search/users2?q=${keyWord}`).then(
            response => {
                console.log('联系服务器成功了');
                return response.json()
            },
            error => {
                console.log('联系服务器失败了',error);
                return new Promise(()=>{})
            }
        ).then(
            response => {console.log('获取数据成功了',response);},
            error => {console.log('获取数据失败了',error);}
        ) */

        //发送网络请求---使用fetch发送（优化）
        try {
            const response = await fetch(`api1/search/users?q=${values}`)
            const data = await response.json()
            console.log(data);
            PubSub.publish('token', { isLoading: false, users: data.items })
        } catch (error) {
            console.log('请求出错', error);
            PubSub.publish('token', { isLoading: false, err: error.message })
        }

解析内容promise的返回对象是promise的话又需要.then和两个回调函数参数来链式调用并且每一步骤需要写
成功的回调失败的回调如果不是promise的话害需要返回一个空promise来中止new promise (()=>{})

而await 和async的话呢直接等待成功的结果，赋值并再次等待成功后直接赋值，但可能失败所有直接try{
       所有请求，并用catch(error)捕获所有错误
}