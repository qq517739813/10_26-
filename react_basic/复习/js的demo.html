<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>demo</title>
    <meta http-equiv="refresh">
</head>

<body>
    <div>123</div>
    <script>
        /*
        解析器在调用函数每次都会向函数递进一个隐含的参数，
        这个隐含的参数就是this，this指向的是一个对象
        */
        // function fn (){
        //     console.log(this);
        // };
        // const obj = {
        //     name:'zs',
        //     sayname:fn
        // }
        // const fnc  =  ()=>{
        //     console.log(this);
        // }
        // // obj.sayname()
        // fn.bind(obj,[123,34])()
        // fnc()

        // 解构赋值，对象和数组
        // let [a,b,c,d,e,f,g,h,i] =  temp  =  [1,2,3,4,5,6,7,8,9,10]
        // console.log(temp['6']);
        // let {a1} = { a1: [1,2,3,],b1: [2,3, 4,]}
        // console.log(a1);
        // 两数之和
        // let nums = [2, 7, 11, 15]
        // let target = 9
        // const twoSum = function (nums, target) {
        //     const map = new Map();
        //     for (let i = 0; i < nums.length; i++) {
        //         const diff = target - nums[i];
        //         if (map.has(diff)) {
        //             return [map.get(diff), i];
        //         }
        //         map.set(nums[i], i);
        //     }
        // };
        // console.log(twoSum(nums, target));

        // const array1 = ['a', 'b', 'c', 'd', 'e'];

        // Copy to index 0 the element at index 3
        // console.log(array1.copyWithin(0, 3, 4));
        // Expected output: Array ["d", "b", "c", "d", "e"]

        // Copy to index 1 all elements from index 3 to the end
        // console.log(array1.copyWithin(1, 3));
        // Expected output: Array ["d", "d", "e", "d", "e"]

        /*没能很理解这里的定义函数中加this属性，可能又是忘了*/
        /*this复习，解析器在调用函数每次都会向函数内部传递一个隐式参数this，
        this指向的是一个对象，这个对象我们称之函数执行的上下文
        根据函数调用方式不通，this指向不通的对象。简单理解就是.的左边
        如果是直接调用
        function fun(){console.log(this)}
        fun()这里打印的是object window 指向全局的window对象，实际上就是window.fun()
        如果是通过 obj = {
            name:'tss',
            age:'20',
            sayhello:fun
        }
        obj.sayhello() 指向的是obj对象 则打赢的是obj整个对象 (函数形式调用是指向window fun()
                                                    方法形式调用是指向对象如obj.sayhello() 这样才叫方法)*/
        // const fun1 = function(){
        //    console.log(123);
        // }
        // let fun2 = fun1()
        // console.log(fun2);
        /*64.构造函数/ 就是普通的函数用来创建对象的函数叫构造函数 加了new就会返回一个对象出来
        // let fun = fun1() 这样就是普通函数调用
        // let fun = New fun1()这样就是构造函数
        /*构造函数的执行流程
        1.立即创建一个新的对象new 之后立马会在内存开辟一个对象储存，
        2.将新建的对象设置为函数中的this
        3.逐行执行函数中的代码
        4.将新建的对象作为返回值返回*/
        //  function Person (){
        //    console.log(123);
        //    alert(this);这里的this就是per 新建的对象对应第二句,在构造函数里的this跟per是一个东西
        //当函数以构造函数的形式创建时，this就是创建的那个对象
        //明白了，这里的this就是创建的对象，this.name就是增加了一个属性赋值了，
        //比如this.name  =name 调用函数传进来的值传给创建对象的属性name
        // }
        // 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类，
        // 我们将通过一个构造函数创建的对象，称为该类的实例
        // let per = new Person();
        // console.log(per);
        // function Person(params) {
        //     this.name = '123'
        //     this.age = 15
        // }
        // const per = new Person();
        // console.log(window );

        /*
        原型prototype
        我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
            这个属性对应着一个对象，这个对象就是我们所谓的原型对象
            如果函数作为普通函数调用prototype没有任何作用
            当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，
                指向改构造函数的原型对象，可以通过_proto_来访问该属性

            所有同一类的实例都能访问到原型对象
                例：
                 function MyClass() { };
                    console.log(MyClass.prototype);
                    const mc = new MyClass();
                    const mc2 = new MyClass();
                    console.log(mc.__proto__);都是指向的MyClass的原型对象

            使用in在检查某个对象中是否有该属性时，对象中没有原型中有也是会返回true
            MyClass.prototype.name = "MyClass";
            const mc = new MyClass();
            console.log( 'name' in mc );
             function MyClass( name ) {
            this.name = name;
        }
        mc = new MyClass();
        MyClass.prototype.age = "123";
        console.log(mc);




        数组内容
         const arr = [1, 2, 3, 4, 5, 6, 7, 8]
        const result = arr.push(10,20)
        console.log(arr, result);

        const ar1 = arr.pop();
        console.log(ar1);
        const ar2 = arr.pop();
        console.log(ar2);
        const ar3 = arr.pop();
        console.log(ar3);

        const ar4 = arr.unshift('数组前面加一个值并返回新的数组');

        const ar5 = arr.shift() //数组前面删一个，并返回长度




        arr.forEach(function(ar) {
            console.log('回调函数'); //由自己创建但不是自己调用的称为回调函数
        })


          const arr = ['小米','红米','紫米','X']
        arr.forEach((value,index,arra) => {
            console.log(value,index,arra);
        })

        普通函数 关键字 函数名 函数体
        function name(params) {
            return params
        }

        匿名函数，没有名字的函数，赋给变量
        (function (){
            console.log('123');
        })()

        箭头函数 ,没有名字，没有this指向，会指向上下文
        let name = (name)=>{console.log(name);}
        */

        // const person = {
        //     name: 'John',
        //     age: 18,
        //     sayhello: {
        //         name : name,
        //         say:  ()=> {console.log(this);}
        //     }
        // }
        // person.sayhello.say()

        /*
//      递归算法找多层对象的name属性
// 后端传过来的数据，这里应该是res.data，这里为了方便大家观看，用模拟数据
var serverData = {
    name: "小明",
    children: {
        name: "小红",
        relation: "情侣",
        children: {
            name: "小蓝",
            relation: "同学",
            children: {
                name: "小绿",
                relation: "同学"
                // ...
                // 这里还有很多层，且层级数是不定的
            }

        }
    }
}
// 定义一个数组，用来存放处理后的数据
var datalist = [];
// 定义递归函数 里面的参数datas就是我们每次调用要处理的对象
function doObj(datas) {
    // 循环每次的对象
    for (let key in datas) {
        // 如果它里面的children还是对象的话，就再调用一次这个函数
        if (typeof datas.children == "object") {
            // 递归，这里的调用传入的参数都是每一层的children对象！！
            doObj(datas.children);
            // CSDN coderYYY
        }
        datalist.push({
            name: datas.name
        });
        // 跳出循环，避免重复push
        break;
    }
}
// 这里第一次调用，参数是serverData一整个对象
doObj(serverData);
console.log(datalist)
// CSDN coderYYY
    */
        /* slice 截取获取，splice删除 slice截取不会改变原数组
        slice截取下表x到第二位的多少数，给返回不会改变原数组
        splice删取下标x到第二位数的多少数，第三位的插入，会删除原数组的内容
        从下标开始截取第二位参数的多少个，
        const arr = ['小米', '红米', '紫米', 'X']
        const newar =  arr.slice(0, 2) //0开始到2结束获取到截掉后面的
        console.log(newar);
        const arr = ['小米', '红米', '紫米', 'X']
        const result  = arr.splice(0,3)
        console.log(arr,result);
        */
        /*
        let result = [1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 4, 5, 5, 3, 2, 4, 5]
        let newarr = ['张三', '小米']
        // console.log([...new Set(result)]);
        for (let i = 0; i < result.length; i++) {
            for (let index = i + 1; index < result.length; index++) {
                if (result[i] === result[index]) {
                    result.splice(index, 1)
                    index--
                }

            }

        }

        console.log([...result,...newarr]) ;*/

        /*字符串
         str = "hello world"
        let newarr = ['张三', '小米','紫米']
        newarr.forEach(element => {
            console.log(element);
        });
        // console.log(newarr.indexOf('小米'));


        */
        /*正则表达式
        -admin
        -admin@qq.com
        -邮件的规则，
            1，前面可以是xxx
            2，跟着一个@
            3，后面可以是xxx
            4，.com获取其他的
        -这些规则就是正则表达式
            计算机可以根据正则表达式，来检查一个字符串是否符合规则
            
        语法 let 变量 = new RegExp("正则表达式","匹配模式");
        使用typeof检查正则对象，会返回object
        let reg = new RegExp("a");这个正则表达式可以来检查一个字符串中是否含有a
        reg.test(str)
        在构造函数中可以传递一个匹配模式作为第二个参数。
            可以是
                i 忽略大小写
                g 全局匹配模式
            let reg = new RegExp("a");
            let reg = new RegExp("a","i")
            let str = "aasdasd"
            console.log(reg.test(str));
            
        test()
            使用这个方法可以检查一个字符串是否符合正则表达式的规则。
            如果符合则返回true 否则返回false    


        使用字面量创建正则表达式 
            语法
            let 变量 = /正则表达式/匹配模式
            reg = /a/i
        一个检查字符串是否a或者b的正则
            reg=  /a|b/
            多个的时候中括号或关系
            reg = /[abdfasdfkj]/
            还有这样
            reg = /[a-z]/ a到z的任意小写字母、
            reg = /[A-Z]/ a到z的任意大写字母、
            reg = /[A-z]/ 任何字母
        
        检查一个字符串是否含有abc or adc or aec
        reg = /[bde]/
        
        除了 
        [^]
        reg = /[^z]/除了z


        根据任何字母拆分字符串
         let reg=  /a|b/
        let str = "1a2b2b2b2b2b2b2b3n4n5nk6i    "
        console.log(str.split(/[A-z]/));

        量词多个包含
        {n} reg = /a{3}/   /a{3，}/ 三次和三次以上
        /n+/ 至少一个
        /n*/
        /*
        
        /^n/ 紧跟着开头

        /n$/ 结尾一个n

        /./任何字符
        let reg = /^1[3-9][0-9]{9}$/
        let str = "18582336041"
        console.log(reg.test(str)); 


        正则表达相关方法
split()
可以根据指定内容将一个字符串拆分为一个数组
参数：
需要一个字符串作为参数，将会根据字符串去拆分数组
可以接收一个正则表达式，此时会根据正则表达式去拆分数组

match()
可以根据正则表达式，从一个字符串中将符合条件的内容提取出来
默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索
我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容
可以为一个正则表达式设置多个匹配模式，且顺序无所谓
match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果

replace()
可以将字符串中指定内容替换为新的内容
参数：
1.被替换的内容，可以接受一个正则表达式作为参数
2.新的内容 空串则为删除""
默认只会替换第一个

search()
可以搜索字符串中是否含有指定内容
如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回1
它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串
serach()只会查找第一个，即使设置全局匹配也没用

正则表达式
正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，
也可以将一个字符串中符合规则的内容提取出来。
创建正则表达式
var reg = new RegExp("正则","匹配模式"); 注意：使用构造函数时，由于它的参数是一个字符串，而\是字符串中转义字符，如果要使用\则需要使用\来代替

var reg = /正则表达式/匹配模式 （匹配模式可以多个一起写：/gi）

语法：
匹配模式：
i:忽略大小写（ignore）
g:全局匹配模式（默认为1次）
设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求

正则语法
| 或
[] 或
[^ ] 除了

**[x-y] x的ascii到y的ascii码之间的值**  
[a-z] 小写字母 （也可以[e-i])
[A-Z] 大写字母
[A-z] 任意字母,但是还包括了其他ASCII在此之中的
[0-9] 任意数字

元符号

检查一个字符串中是否含有 .
. 表示任意字符
在正则表达式中使用\作为转义字符
. 来表示.
\ 表示\

\w
任意字母、数字、_ [A-z0-9_]
\W
除了字母、数字、_ [ ^A-z0-9_]
\d
任意的数字 [0-9]
\D
除了数字 [ ^0-9]
\s
空格
\S
除了空格
\b
单词边界
\B
除了单词边界

量词
通过量词可以设置一个内容出现的次数
量词只对它前边的一个内容起作用
{n} 正好出现n次
{m,n} 出现mn次
{m,} m次以上

+至少一个，相当于{1,}
*个或多个，相当于{0,}
? 0个或1个，相当于{0,1}

边界表达式（不要在java中用，javaScript中用）
^:正则开始
$:正则结束 ：注意结束前一个才是结束匹配

reg = /^a/;  
reg = /b$/;  
方法：
test()
可以用来检查一个字符串是否符合正则表达式
如果符合返回true，否则返回false
例子

去掉两端的空格:

var s = "        	f    afa    ";   
s = s.replace(/^\s*|\s*$/g,"");  

        */
        const person = {
            name,
            say: () => { }
        }


        let reg = /^1[3-9][0-9]{9}$/
        let str = "18582336041"
        let temp = []
        console.log(typeof(temp)); 
    </script>
</body>

</html>